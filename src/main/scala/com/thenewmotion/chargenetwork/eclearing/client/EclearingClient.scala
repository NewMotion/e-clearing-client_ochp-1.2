package com.thenewmotion.chargenetwork.eclearing.client

import java.util
import javax.xml.namespace.QName
import javax.xml.ws.Service
import javax.xml.ws.soap.SOAPBinding

import com.thenewmotion.chargenetwork.eclearing.EclearingConfig
import com.thenewmotion.chargenetwork.eclearing.api.{ChargePoint, CDR, Card}
import com.typesafe.scalalogging.slf4j.Logging
import eu.ochp._1._
import eu.ochp._1_2.OCHP12
import org.apache.cxf.endpoint.Endpoint
import org.apache.cxf.frontend.ClientProxy
import org.apache.cxf.ws.security.wss4j.WSS4JOutInterceptor
import org.apache.wss4j.dom.WSConstants
import org.apache.wss4j.dom.handler.WSHandlerConstants

/**
 * @param cxfClient The SOAP client generated by CXF
 */
class EclearingClient(cxfClient: OCHP12) extends Logging {

  import scala.collection.JavaConverters._
  import com.thenewmotion.chargenetwork.eclearing.Converters._

  def setRoamingAuthorisationList(info: Seq[Card]): Result = {
    val req = new SetRoamingAuthorisationListRequest()
    req.getRoamingAuthorisationInfoArray.addAll(info.map(implicitly[RoamingAuthorisationInfo](_)).asJava)
    val resp = cxfClient.setRoamingAuthorisationList(req)
    Result(resp.getResult.getResultCode.getResultCode, resp.getResult.getResultDescription)
  }

  def roamingAuthorisationList() = {
    val resp = cxfClient.getRoamingAuthorisationList(
      new GetRoamingAuthorisationListRequest)
    resp.getRoamingAuthorisationInfoArray.asScala.toList.map(implicitly[Card](_))
  }

  def setRoamingAuthorisationListUpdate(info: Seq[Card]): Result = {
    val req = new UpdateRoamingAuthorisationListRequest()
    req.getRoamingAuthorisationInfoArray.addAll(info.map(implicitly[RoamingAuthorisationInfo](_)).asJava)
    val resp = cxfClient.updateRoamingAuthorisationList(req)
    Result(resp.getResult.getResultCode.getResultCode, resp.getResult.getResultDescription)
  }

  def roamingAuthorisationListUpdate() = {
    val resp = cxfClient.getRoamingAuthorisationListUpdates(
      new GetRoamingAuthorisationListUpdatesRequest)
    resp.getRoamingAuthorisationInfo.asScala.toList.map(implicitly[Card](_))
  }

  def getCdrs() = {
    val resp: GetCDRsResponse = cxfClient.getCDRs(
      new GetCDRsRequest)
    resp.getCdrInfoArray.asScala.toList.map(implicitly[CDR](_))
  }

  def addCdrs(cdrs: Seq[CDR]) = {
    val req: AddCDRsRequest = new AddCDRsRequest()
    req.getCdrInfoArray.addAll(cdrs.map(implicitly[CDRInfo](_)).asJava)
    val resp = cxfClient.addCDRs(req)
    Result(resp.getResult.getResultCode.getResultCode, resp.getResult.getResultDescription)
  }

  def setChargePointList(info: Seq[ChargePoint]): Result = {
    val req = new SetChargePointListRequest()
    req.getChargepointInfoArray.addAll(info.map(implicitly[ChargePointInfo](_)).asJava)
    val resp = cxfClient.setChargepointList(req)
    Result(resp.getResult.getResultCode.getResultCode, resp.getResult.getResultDescription)
  }

  def chargePointList() = {
    val resp = cxfClient.getChargePointList(
      new GetChargePointListRequest)
    resp.getChargePointInfoArray.asScala.toList.map(implicitly[ChargePoint](_))
  }

  def setChargePointListUpdate(info: Seq[ChargePoint]): Result = {
    val req = new UpdateChargePointListRequest()
    req.getChargePointInfoArray.addAll(info.map(implicitly[ChargePointInfo](_)).asJava)
    val resp = cxfClient.updateChargePointList(req)
    Result(resp.getResult.getResultCode.getResultCode, resp.getResult.getResultDescription)
  }

  def chargePointListUpdate() = {
    val resp = cxfClient.getChargePointListUpdates(
      new GetChargePointListUpdatesRequest)
    resp.getChargePointInfoArray.asScala.toList.map(implicitly[ChargePoint](_))
  }

}

case class Result(resultCode: String,
  resultDescription: String)

object EclearingClient {

  // need to pass the pw to the PwCallbackHandler somehow,
  // but can't pass it to the constructor, else wss4j won't be
  // able to instantiate it
  var password = ""

  def apply(conf: EclearingConfig):EclearingClient = {
    password = conf.password
    lazy val cxfClient = EclearingClient.createCxfClient(conf)
    new EclearingClient(cxfClient)
  }

  private def createCxfClient(conf: EclearingConfig): OCHP12 = {
    val endpoint_address = conf.wsUri
    val servicePort: QName = new QName(endpoint_address, "service port")
    val service: Service = Service.create(null,servicePort)
    service.addPort(servicePort, SOAPBinding.SOAP11HTTP_BINDING, endpoint_address)
    addWSSHeaders(conf, service.getPort(servicePort, classOf[OCHP12]))
  }

  private def addWSSHeaders(conf: EclearingConfig, port: OCHP12): OCHP12 = {
    val client = ClientProxy.getClient(port)
    val cxfEndpoint: Endpoint = client.getEndpoint

    val outProps = new util.HashMap[String, Object]()

    outProps.put(WSHandlerConstants.ACTION, WSHandlerConstants.USERNAME_TOKEN)
    outProps.put(WSHandlerConstants.USER, conf.user)
    outProps.put(WSHandlerConstants.PASSWORD_TYPE, WSConstants.PW_TEXT)
    outProps.put(WSHandlerConstants.PW_CALLBACK_CLASS,
      new PwCallbackHandler().getClass.getName)

    val wssOut = new WSS4JOutInterceptor(outProps)
    cxfEndpoint.getOutInterceptors.add(wssOut)
    port
  }

  import javax.security.auth.callback.{Callback, CallbackHandler}

import org.apache.wss4j.common.ext.WSPasswordCallback
  private class PwCallbackHandler  extends CallbackHandler {

    def handle( callbacks: Array[Callback]) = {
      val pc: WSPasswordCallback  = callbacks(0).asInstanceOf[WSPasswordCallback]
      pc.setPassword(password)
    }
  }

}
